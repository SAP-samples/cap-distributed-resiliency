/* eslint-disable camelcase */
'use strict';
var request = require('request');
var tokenUtils = require('./token-utils');
var uuid = require('uuid/v4');

module.exports.logRequestError = function(req, message){
  if (req && req.logger && process.env.SAAS_APPROUTER){
    req.logger.error(message);
  }
};

module.exports.logRequestSetTenant = function(req, tenant){
  if (req && req.logger){
    req.logger.setTenantId(tenant);
    if (!req.logger.getCorrelationId()){
      req.logger.setCorrelationId(req.headers['x-correlationid'] || req.headers['x-request-id'] ||
        req.headers['x-vcap-request-id'] || uuid());
    }
  }
};

module.exports.getApplicationLogs = function(req,res){
  return new Promise((resolve,reject) => {
    tokenUtils.getAuthenticationJar(function (err, jar) {
      if (err) {
        return reject(err);
      }
      let query = kibanaQuery(req);
      let requestOptions = {
        url: process.env.LOGS_URL + '/elasticsearch/_msearch',
        jar: jar,
        headers: {
          'kbn-xsrf': 'true',
          'Content-Type': 'application/x-ndjson'
        },
        body: query
      };
      module.exports.callKibanaServer(requestOptions,query, function(err, respBody) {
        let logs = [];
        respBody.responses.forEach((response) => {
          response.hits.hits.forEach((hit) => {
            if (hit._source.msg) {
              logs.push({
                message: hit._source.msg,
                correlationId: hit._source.correlation_id,
                timestamp: hit._source['@timestamp'],
                level: hit._source.level
              });
            }
          });
        });
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify(logs));
      });
    });
  });
};

module.exports.callKibanaServer = function (requestOptions,query, cb){
  request.post(requestOptions, function(err,response,body) {
    if (err || response.statusCode !== 200) {
      let error = new Error('Failed to execute query ' + query + ' response status ' +
      response.statusCode + ' ' + body ? body : '' + err);
      return cb(error);
    }
    let respBody = JSON.parse(response.body);
    cb(null, respBody);
  });
};

function kibanaQuery(req) {
  const timeRange = 1440; // One day in minutes
  let timestampNow = new Date();
  let end = timestampNow.getTime();
  let start = end - timeRange * 60 * 1000;
  let timestampYesterday = new Date(timestampNow);
  timestampYesterday.setHours(timestampYesterday.getHours() - 24);
  let appKeyParts = req.headers['x-application-key'].split('.');
  let appName = appKeyParts[1].split('-')[0];
  let appKey = appKeyParts[0] + '.' + appName;
  let tenantKey = req.tenant + '-' + appKey;
  return kibanaDayQuery(timestampNow, start, end, tenantKey);
}

function kibanaDayQuery(timestampReferenceDay, startTime, endTime, tenant) {
  let todayString = timestampReferenceDay.toISOString().substring(0, 10);
  let kibanaQuery0 = {
    'index': ['logstash-2016.07.01-es5'],
    'ignore_unavailable': true
  };
  kibanaQuery0.index = 'logstash-' + todayString.replace(/-/g, '.');

  let kibanaQuery1 = { // AppELK template
    'size': 10000,
    '_source': ['msg','@timestamp', 'level', 'correlation_id'],
    'query': {
      'bool': {
        'must': [{
          'range': {
            '@timestamp': {
              'format': 'epoch_millis',
              'gte': startTime,
              'lte': endTime
            }
          }
        }, {
          'match': {
            'tenant_id': tenant
          }
        },{
          'match': {
            'level': 'ERROR'
          }
        }]
      }
    }
  };
  return JSON.stringify(kibanaQuery0) + '\n' + JSON.stringify(kibanaQuery1) + '\n';
}