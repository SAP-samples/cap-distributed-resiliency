'use strict';

const util = require('util');

const debug = require('debug');
const debugTrace = debug('xssec:validators');
const debugError = debug('xssec:validators');

const jwt = require('jsonwebtoken');
const tokenInfo = require('./tokeninfo')

const DOT = ".";

const ValidationResults = new function () {
    function Result(suc, desc) {
        var state = suc;
        var description = desc || "";

        this.isValid = function () {
            return suc === true;
        }

        this.isErroneous = function () {
            return suc === false;
        }

        this.getErrorDescription = function () {
            return description;
        }
    };

    this.createValid = function () {
        return new Result(true);
    }

    this.createInvalid = function (description) {
        return new Result(false, description)
    }
};

function JwtAudienceValidator(clientId) {
    var clientIds = [];
    var foreignMode = false;

    this.configureTrustedClientId = function (clientId) {
        if (clientId) {
            clientIds.push(clientId);
        }

        debugTrace("configured JwtAudienceValidator with clientId", clientId);
        return this;
    }

    this.validateToken = function (audiencesFromToken, scopesFromToken, cid) {
        foreignMode = false;
        var allowedAudiences = extractAudiencesFromToken(audiencesFromToken, scopesFromToken || [], cid);
        if (validateSameClientId(cid) === true || validateAudienceOfXsuaaBrokerClone(allowedAudiences) === true || validateDefault(allowedAudiences) === true) {
            return ValidationResults.createValid();
        }

        return ValidationResults.createInvalid("Jwt token with audience: " + util.inspect(allowedAudiences) + " is not issued for these clientIds: " + util.inspect(clientIds) + ".");
    }

    this.isForeignMode = function() {
        return foreignMode;
    }

    function validateSameClientId(cidFromToken) {
        if(!cidFromToken || !clientId) {
            return false;
        }

        return cidFromToken.trim() === clientId.trim();
    }

    //iterate over all configured clientIds and return true of the cb returns true
    function forEachClientId(cb) {
        for (var i = 0; i < clientIds.length; ++i) {
            if (cb(clientIds[i]) === true) {
                return true;
            }
        }

        return null;
    }

    function validateDefault(allowedAudiences) {
        return forEachClientId(function (configuredClientId) {
            if (allowedAudiences.includes(configuredClientId)) {
                return true;
            }
        });
    }

    function validateAudienceOfXsuaaBrokerClone(allowedAudiences) {
        var ret = forEachClientId(function (configuredClientId) {
            if (configuredClientId.includes("!b")) { //isBrokerClientId
                for (var i = 0; i < allowedAudiences.length; ++i) {
                    var audience = allowedAudiences[i];
                    if (audience.endsWith("|" + configuredClientId)) {
                        return true;
                    }
                }
            }
        });

        if(ret === null) {
            foreignMode = true;
        }
        return ret;
    }

    this.getListOfAudiencesFromToken = function(aud, scopes, cid) {
        return extractAudiencesFromToken(aud || [], scopes || [], cid);
    }

    function extractAudiencesFromToken(aud, scopes, cid) {
        var audiences = [];
        var tokenAudiences = aud || [];

        for (var i = 0; i < tokenAudiences.length; ++i) {
            var audience = tokenAudiences[i];
            if (audience.indexOf(DOT) > -1) {
                // CF UAA derives the audiences from the scopes.
                // In case the scopes contains namespaces, these needs to be removed.
                var aud = audience.substring(0, audience.indexOf(DOT)).trim();
                if (aud && !audiences.includes(aud)) {
                    audiences.push(aud);
                }
            } else {
                audiences.push(audience);
            }
        }

        if (audiences.length == 0) {
            for(var i=0;i < scopes.length;++i) {
                var scope = scopes[i];
                if (scope.indexOf(DOT) >-1) {
                    var aud = scope.substring(0, scope.indexOf(DOT)).trim();
                    if(aud && !audiences.includes(aud)) {
                        audiences.push(aud);
                    }
                }
            }
        }
        
        if(cid && audiences.indexOf(cid) === -1) {
            audiences.push(cid);
        }
        
        return audiences;
    }

    //allow an empty constructor
    if (clientId) {
        this.configureTrustedClientId(clientId);
    }
};

function JwtTokenValidator(verificationKey, config) {
    var foreignMode = false;

    this.isForeignMode = function() {
        return foreignMode;
    }

    //prepare JWT validators
    this.validateToken = function (accessToken, cb) {
        function returnError(code, errorString) {
            debugError('\n' + errorString);
            var error = new Error(errorString);
            error.statuscode = code;
            return cb(error);
        }

        var token = new tokenInfo(accessToken);        

        token.verify(verificationKey.getCallback(token),
            function (err, token) {
                var decodedToken = token.getPayload();

                if (err) {
                    debugError(err.statuscode);
                    debugError(err.message);
                    debugError(err.stack);                    
                    return cb(err, token);
                }

                if (!decodedToken.cid) {
                    return returnError(400, 'Client Id not contained in access token. Giving up!');
                }

                if (!decodedToken.zid) {
                    return returnError(400, 'Identity Zone not contained in access token. Giving up!');
                }

                var audienceValidator = new JwtAudienceValidator(config.clientid);
                if (config.xsappname) {
                    audienceValidator.configureTrustedClientId(config.xsappname);
                }

                var valid_result = audienceValidator.validateToken(decodedToken.aud, decodedToken.scope, decodedToken.cid);
                if (!valid_result.isValid()) {
                    return returnError(401, valid_result.getErrorDescription());
                }

                if(config.clientid !== decodedToken.cid) {
                    foreignMode = audienceValidator.isForeignMode();
                }

                cb(null, token);
            }
        );  
    };
};

module.exports = {
    JwtAudienceValidator: JwtAudienceValidator,
    JwtTokenValidator: JwtTokenValidator
};