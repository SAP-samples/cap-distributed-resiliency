'use strict';

const constants = require('./constants');
const request = require('request');
const requestRetry = require('requestretry');
const url = require('url');

// use environment variable DEBUG with value 'xssec:*' for trace/error messages
const debug = require('debug');
const debugTrace = debug('xssec:requests');
const debugError = debug('xssec:requests');

debugError.log = console.error.bind(console);
debugTrace.log = console.log.bind(console);

module.exports.requestUserToken = function (securityContext, serviceCredentials, additionalAttributes, scopes, adaptSubdomain, cb) {
    // input validation
    if (!serviceCredentials) {
        var error = new Error('Parameter serviceCredentials is missing but mandatory.');
        return cb(error, null);
    }
    if (!serviceCredentials.clientid || !serviceCredentials.clientsecret) {
        var error = new Error('Invalid service credentials: Missing clientid/clientsecret.');
        return cb(error, null);
    }
    if (!serviceCredentials.url) {
        var error = new Error('Invalid service credentials: Missing url.');
        return cb(error, null);
    }
    // adapt subdomain in service url, if necessary
    var urlWithCorrectSubdomain = serviceCredentials.url;
    if (adaptSubdomain === true) {
        var tokenSubdomain = securityContext.getSubdomain();
        var tokenRequestSubdomain = null;
        var uaaUrl = url.parse(serviceCredentials.url);
        if (uaaUrl.hostname.indexOf('.') === -1) {
            tokenRequestSubdomain = null;
        } else {
            tokenRequestSubdomain = uaaUrl.hostname.substring(0, uaaUrl.hostname.indexOf('.'));
        }
        if (tokenSubdomain !== null && tokenRequestSubdomain != null && tokenSubdomain !== tokenRequestSubdomain) {
            urlWithCorrectSubdomain = uaaUrl.protocol + "//" + tokenSubdomain + uaaUrl.host.substring(uaaUrl.host.indexOf('.'), uaaUrl.host.size);
        }
    }
    // jwt bearer flow
    var options = {
        url: urlWithCorrectSubdomain + '/oauth/token',
        headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/x-www-form-urlencoded',
            'User-Agent': constants.USER_AGENT
        },
        form: {
            grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
            response_type: 'token',
            client_id: serviceCredentials.clientid,
            assertion: securityContext.getAppToken()
        },
        auth: {
            user: serviceCredentials.clientid,
            pass: serviceCredentials.clientsecret
        },
        timeout: 10*1000
    };

    if (scopes !== null) {
        options.url = options.url + "&scope=" + scopes;
    }
    if (additionalAttributes !== null) {
        var authorities = { "az_attr": additionalAttributes };
        options.url = options.url + "&authorities=" + encodeURIComponent(JSON.stringify(authorities));
    }

    debugTrace('requestUserToken::HTTP Call with %O', options);
    request.post(
        options,
        function (error, response, body) {
            if (error) {
                if (error.code === 'ETIMEDOUT' && error.connect === true) {
                    debugError('requestToken: HTTP connection timeout.');
                }
                debugError(error.message);
                debugError(error.stack);
                return cb(error, null);
            }
            if (response.statusCode !== 200) {
                return cb(new Error(response.statusCode + " - " + body));
            }
            var json = null;
            try {
                json = JSON.parse(body);
            } catch (e) {
                return cb(e, null);
            }
            return cb(null, json.access_token)
        }
    );
}

module.exports.requestClientCredentialsToken = function (securityContext, serviceCredentials, additionalAttributes, cb) {
    // input validation
    if (!serviceCredentials) {
        var error = new Error('Parameter serviceCredentials is missing but mandatory.');
        return cb(error, null);
    }
    if (!serviceCredentials.clientid || !serviceCredentials.clientsecret) {
        var error = new Error('Invalid service credentials: Missing clientid/clientsecret.');
        return cb(error, null);
    }
    if (!serviceCredentials.url) {
        var error = new Error('Invalid service credentials: Missing url.');
        return cb(error, null);
    }
    // adapt subdomain in service url, if necessary
    var urlWithCorrectSubdomain = serviceCredentials.url;
    var tokenSubdomain = securityContext.getSubdomain();
    var tokenRequestSubdomain = null;
    var uaaUrl = url.parse(serviceCredentials.url);
    if (uaaUrl.hostname.indexOf('.') === -1) {
        tokenRequestSubdomain = null;
    } else {
        tokenRequestSubdomain = uaaUrl.hostname.substring(0, uaaUrl.hostname.indexOf('.'));
    }
    if (tokenSubdomain !== null && tokenRequestSubdomain != null && tokenSubdomain !== tokenRequestSubdomain) {
        urlWithCorrectSubdomain = uaaUrl.protocol + "//" + tokenSubdomain + uaaUrl.host.substring(uaaUrl.host.indexOf('.'), uaaUrl.host.size);
    }
    // client credentials flow
    var options = {
        url: urlWithCorrectSubdomain + '/oauth/token?grant_type=client_credentials&response_type=token',
        headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/x-www-form-urlencoded',
            'User-Agent': constants.USER_AGENT
        },
        auth: {
            user: serviceCredentials.clientid,
            pass: serviceCredentials.clientsecret
        },
        timeout: 2 * 1000
    };
    if (additionalAttributes !== null) {
        var authorities = { "az_attr": additionalAttributes };
        options.url = options.url + "&authorities=" + encodeURIComponent(JSON.stringify(authorities));
    }
    debugTrace('requestClientCredentialsToken::HTTP Call with %O', options);
    requestRetry.post(
        options,
        function (error, response, body) {
            if (error) {
                if (error.code === 'ETIMEDOUT' && error.connect === true) {
                    debugError('requestToken: HTTP connection timeout.');
                }
                debugError(error.message);
                debugError(error.stack);
                return cb(error);
            }
            if (response.statusCode !== 200) {
                return cb(new Error(response.statusCode + " - " + body));
            }
            var json = null;
            try {
                json = JSON.parse(body);
            } catch (e) {
                return cb(e);
            }
            return cb(null, json.access_token);
        }
    );
};


module.exports.fetchKeyFromXSUAA = function (tokenKeyUrl, zid, cb) {
    // try to obtain key from UAA
    var options = {
        url: tokenKeyUrl,
        timeout: 2000,
        headers: {
            "User-Agent": constants.USER_AGENT,
        },
        followRedirect: false,
        maxAttempts: 3,
        retryDelay: 500,
        retryStrategy: requestRetry.RetryStrategies.HTTPOrNetworkError
    };    

    requestRetry.get(options, function (err, response, body) {
        if (err) {
            return cb(err);
        }

        if (response.statusCode !== 200) {
            var error = new Error('Call was not successful. Error Code: ' + response.statusCode + " " + body);
            error.statuscode = response.statusCode;
            error.body = body;
            return cb(error);
        }

        try {
            var json = JSON.parse(body);
            return cb(null, json);
        } catch (e) {
            var error = new Error('Error parsing response from UAA: ' + e)
            return cb(error);
        }
    });
}