'use strict';
const keycache = require('./keycache');

const constants = require('./constants');
const url = require('url');

var debug = require('debug');
var debugTrace = debug('xssec:verificationkey');

//keyCache is now configureable using the config object
var keyCache = null;

function VerificationKey(config) {
    var tokenInfo = null;
    this.getCallback = function(token) {
        tokenInfo = token;
        return this.loadKey.bind(this);
    }

    function cleanUp(pem) {
        if(!pem) {
            return null;
        }
        //the old ccl based jwt verification library was able to read malformed PEM formatted input.
        //but with the jsonwebtoken module we need to clean up some PEM errors before using it...
        if(pem.indexOf("-----BEGIN PUBLIC KEY-----\n") === -1) {
            pem = pem.replace("-----BEGIN PUBLIC KEY-----", "-----BEGIN PUBLIC KEY-----\n");
        }
        if(pem.indexOf("\n-----END PUBLIC KEY-----") === -1) {
            pem = pem.replace("-----END PUBLIC KEY-----", "\n-----END PUBLIC KEY-----");
        }
        return pem;
    }

    function validateJku(jkuUrl, uaaDomain) {
        if (!uaaDomain) {
            return 'Service is not properly configured in \'VCAP_SERVICES\', attribute \'uaadomain\' is missing. Use legacy-token-key.';
        }

        var tokenKeyUrl = url.parse(jkuUrl);
        if (tokenKeyUrl.hostname.substring(tokenKeyUrl.hostname.indexOf(uaaDomain), tokenKeyUrl.hostname.length) !== uaaDomain) {
            return 'JKU of the JWT token (' + jkuUrl + ') does not match with the uaa domain (' + uaaDomain + '). Use legacy-token-key.';
        }
    }

    this.loadKey = function(accessToken, cb) {
        var zid = tokenInfo.getPayload().zid;                
        if (!accessToken.kid || accessToken.kid == 'legacy-token-key' || !accessToken.jku) {
            return cb(null, cleanUp(config.verificationkey));
        }

        var errorString = validateJku(accessToken.jku, config.uaadomain);

        if(errorString) {
            debugTrace('\n' + errorString);
            return cb(null, cleanUp(config.verificationkey));
        }

        if(!keyCache) {
            keyCache = new keycache.KeyCache(config.keyCache.cacheSize, config.keyCache.expirationTime);
        }

        //try to get a key from KeyCache 
        keyCache.getKey(accessToken.jku, accessToken.kid, zid, function(err, key) {
            if (err) {
                debugTrace('\n', err);
                return cb(null, cleanUp(config.verificationkey));
            } else {
                return cb(null, cleanUp(key));
            }
        });
    }
};

module.exports = VerificationKey;
