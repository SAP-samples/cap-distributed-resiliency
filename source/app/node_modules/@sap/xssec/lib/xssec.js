'use strict';
const constants = require('./constants');
const url = require('url');

const requests = require('./requests');

// use environment variable DEBUG with value 'xssec:*' for trace/error messages
var debug = require('debug');
var debugTrace = debug('xssec:securitycontext');
var debugError = debug('xssec:securitycontext');

const JwtTokenValidator = require('./validator').JwtTokenValidator;
const VerificationKey = require('./verificationkey');

debugError.log = console.error.bind(console);
debugTrace.log = console.log.bind(console);

function throw500(errorString) {
    debugError('\n' + errorString);
    var error = new Error(errorString);
    error.statuscode = 500; //500 (Invalid config)
    throw error;
}

//For Backward compatibilty
exports.createSecurityContext = function (token, config, cb) {
    try {
        var securityContext = new SecurityContext(config);
        securityContext.verifyToken(token, cb);
    } catch (e) {
        cb(e);
    }
}

function SecurityContext(config) {
    var userInfo = {
        logonName: '',
        givenName: '',
        familyName: '',
        email: ''
    };

    var token;
    var xsappname;
    var scopes;
    var samlToken;
    var clientId;
    var subaccountid;
    var zid;
    var subdomain = null;
    var origin = null;
    var userAttributes;
    var additionalAuthAttributes;
    var serviceinstanceid = null;
    var grantType;
    var expirationDate;

    var tokenInfo = null;

    var isForeignMode = false;

    function validateXSAPPNAME() {
        if (!config.xsappname) {
            if (!process.env.XSAPPNAME) {
                var errorString = 'Invalid config: Missing xsappname.\n'
                    + 'The application name needs to be defined in xs-security.json.';
                return throw500(errorString);
            } else {
                xsappname = process.env.XSAPPNAME;
                debugTrace('\nXSAPPNAME defined in manifest.yml (legacy).\n'
                    + 'You should switch to defining xsappname in xs-security.json.');
            }
        } else {
            if (!process.env.XSAPPNAME) {
                xsappname = config.xsappname;
            } else {
                if (process.env.XSAPPNAME == config.xsappname) {
                    xsappname = process.env.XSAPPNAME;
                    debugTrace('\nThe application name is defined both in the manifest.yml (legacy) \n'
                        + 'as well as in xs-security.json. Remove it in manifest.yml.');
                } else {
                    var errorString = 'Invalid config: Ambiguous xsappname.\n'
                        + 'The application name is defined with different values in the manifest.yml (legacy)\n'
                        + 'as well as in xs-security.json. Remove it in manifest.yml.';
                    return throw500(errorString);
                }
            }
        }
    }

    function ctor() {
        // validate config input
        debugTrace('\nConfiguration (note: clientsecret might be contained but is not traced): ' + 
            JSON.stringify(config, function(key, value) {
                return key === 'clientsecret' ? undefined : value;
            }, 4));

        // validate config input
        if (!config) {
            return throw500('Invalid config (missing).');
        }

        validateXSAPPNAME();

        if (!config.clientid) {
            return throw500('Invalid config: Missing clientid.');
        }
        if (!config.clientsecret) {
            return throw500('Invalid config: Missing clientsecret.');
        }
        if (!config.url) {
            return throw500('Invalid config: Missing url.');
        }

        if(!config.keyCache) {
            config.keyCache = {
                expirationTime: constants.KEYCACHE_DEFAULT_CACHE_ENTRY_EXPIRATION_TIME_IN_MINUTES,
                cacheSize: constants.KEYCACHE_DEFAULT_CACHE_SIZE
            };
            debugTrace("Using KeyCache with default values %o", config.keyCache);
        } else {
            if(config.keyCache.expirationTime) {
                //if it's provided it has to be a number bigger than zero
                if(typeof config.keyCache.expirationTime !== 'number' || config.keyCache.expirationTime < constants.KEYCACHE_DEFAULT_CACHE_ENTRY_EXPIRATION_TIME_IN_MINUTES) {
                    debugError("keyCache.expirationTime has to be a Number with the value of at least " + constants.KEYCACHE_DEFAULT_CACHE_ENTRY_EXPIRATION_TIME_IN_MINUTES + ". taking default value.");
                    config.keyCache.expirationTime = constants.KEYCACHE_DEFAULT_CACHE_ENTRY_EXPIRATION_TIME_IN_MINUTES;
                }
            } else {
                config.keyCache.expirationTime = constants.KEYCACHE_DEFAULT_CACHE_ENTRY_EXPIRATION_TIME_IN_MINUTES;
            }

            if(config.keyCache.cacheSize) {
                //if it's provided it has to be a number bigger than zero
                if(typeof config.keyCache.cacheSize !== 'number' || config.keyCache.cacheSize < constants.KEYCACHE_DEFAULT_CACHE_SIZE) {
                    debugError("keyCache.cacheSize has to be a Number of at least " + constants.KEYCACHE_DEFAULT_CACHE_SIZE + ". taking default value");
                    config.keyCache.cacheSize = constants.KEYCACHE_DEFAULT_CACHE_SIZE;
                }
            } else {
                config.keyCache.cacheSize = constants.KEYCACHE_DEFAULT_CACHE_SIZE;
            }

            debugTrace("Using KeyCache with custom values %o", config.keyCache);
        }
    }

    function ifNotClientCredentialsToken(functionName, value) {
        if (grantType === constants.GRANTTYPE_CLIENTCREDENTIAL) {
            var errorString = '\nCall to ' + functionName + ' not allowed with a token of grant type ' + constants.GRANTTYPE_CLIENTCREDENTIAL + '.';
            debugTrace(errorString);
            return null;
        }
        return value;
    }

    this.getSubaccountId = function () {
        return subaccountid;
    };

    this.getZoneId = function () {
        return zid;
    };

    this.getSubdomain = function () {
        return subdomain;
    };

    this.getClientId = function () {
        return clientId;
    };

    this.getExpirationDate = function () {
        return expirationDate;
    };

    this.getOrigin = function () {
        return origin;
    };

    this.getLogonName = function () {
        return ifNotClientCredentialsToken('SecurityContext.getLogonName', userInfo.logonName);
    };

    this.getGivenName = function () {
        return ifNotClientCredentialsToken('SecurityContext.getGivenName', userInfo.givenName);
    };

    this.getFamilyName = function () {
        return ifNotClientCredentialsToken('SecurityContext.getFamilyName', userInfo.familyName);
    };

    this.getEmail = function () {
        return ifNotClientCredentialsToken('SecurityContext.getEmail', userInfo.email);
    };

    this.getUserName = function () {
        if (grantType === constants.GRANTTYPE_CLIENTCREDENTIAL) {
            return `client/${clientId}`;
        } else {
            return this.getUniquePrincipalName(origin, userInfo.logonName);
        }
    };

    this.getUniquePrincipalName = function (origin, logonName) {
        if(!ifNotClientCredentialsToken('SecurityContext.getUniquePrincipalName', true)) {
            return null;
        }
        if (!origin) {
            debugTrace('Origin claim not set in JWT. Cannot create unique user name. Returning null.');
            return null;
        }
        if (!logonName) {
            debugTrace('User login name claim not set in JWT. Cannot create unique user name. Returning null.');
            return null;
        }
        if (origin.includes('/')) {
            debugTrace('Illegal \'/\' character detected in origin claim of JWT. Cannot create unique user name. Retuning null.');
            return null;
        }
        return `user/${origin}/${logonName}`;
    };

    this.getHdbToken = function () {
        if (userAttributes && isForeignMode) {
            debugTrace('\nThe SecurityContext has been initialized with an access token of a\n'
                + 'foreign OAuth Client Id and/or Identity Zone. Furthermore, the \n'
                + 'access token contains attributes. Due to the fact that we want to\n'
                + 'restrict attribute access to the application that provided the \n'
                + 'attributes, the getHdbToken function does not return a valid token.\n');
            return null;
        }

        return samlToken ? samlToken : this.getAppToken();
    };

    this.getAppToken = function () {
        return token;
    };

    this.getTokenInfo = function() {
        return tokenInfo;
    }

    this.getAttribute = function (name) {
        if(!ifNotClientCredentialsToken('SecurityContext.getAttribute', true)) {
            return null;
        }
        if (!userAttributes) {
            debugTrace('\nThe access token contains no user attributes.\n');
            return null;
        }
        if (isForeignMode) {
            debugTrace('\nThe SecurityContext has been initialized with an access token of a\n'
                + 'foreign OAuth Client Id and/or Identity Zone. Furthermore, the \n'
                + 'access token contains attributes. Due to the fact that we want to\n'
                + 'restrict attribute access to the application that provided the \n'
                + 'attributes, the getAttribute function does not return any attributes.\n');
            return null;
        }
        if (!name) {
            debugTrace('\nInvalid attribute name (may not be null, empty, or undefined).');
            return null;
        }
        if (!userAttributes[name]) {
            debugTrace('\nNo attribute "' + name + '" found for user "' + this.getLogonName() + '".');
            return null;
        }
        return userAttributes[name];
    };

    this.getAdditionalAuthAttribute = function (name) {
        if (!additionalAuthAttributes) {
            debugTrace('\nThe access token contains no additional authentication attributes.\n');
            return null;
        }
        if (!name) {
            debugTrace('\nInvalid attribute name (may not be null, empty, or undefined).');
            return null;
        }
        if (!additionalAuthAttributes[name]) {
            debugTrace('\nNo attribute "' + name + '" found as additional authentication attribute.');
            return null;
        }
        return additionalAuthAttributes[name];
    };

    this.getCloneServiceInstanceId = function () {
        return serviceinstanceid;
    };

    this.isInForeignMode = function () {
        return isForeignMode;
    };

    this.hasAttributes = function () {
        return ifNotClientCredentialsToken('SecurityContext.hasAttributes', userAttributes ? true : false);
    };

    this.checkLocalScope = function (scope) {
        if (!scope || !scopes) {
            return false;
        }
        var scopeName = xsappname + '.' + scope;
        return scopes.indexOf(scopeName) !== -1;
    };

    this.getGrantType = function () {
        return grantType;
    };

    this.checkScope = function (scope) {
        if (!scope || !scopes) {
            return false;
        }

        if (scope.substring(0, constants.XSAPPNAMEPREFIX.length) === constants.XSAPPNAMEPREFIX) {
            scope = scope.replace(constants.XSAPPNAMEPREFIX, xsappname + '.');
        }
        return scopes.indexOf(scope) !== -1;
    };

    this.requestToken = function (serviceCredentials, type, additionalAttributes, cb) {
        if (type === constants.TYPE_USER_TOKEN) {
            return requests.requestUserToken(this, serviceCredentials, additionalAttributes, null, true, cb);
        } else if (type === constants.TYPE_CLIENT_CREDENTIALS_TOKEN) {
            return requests.requestClientCredentialsToken(this, serviceCredentials, additionalAttributes, cb);
        } else {
            return cb(new Error('Invalid grant type.'));
        }
    };

    function cleanUpUserAttributes(attr) {
        if(!attr) {
            return null;
        }
        var len = 0;
        for(var n in attr) {
            ++len;
        }

        return len == 0 ? null : attr;
    }

    function fillContext(encodedToken, info) {
        tokenInfo = info;
        var decodedToken = tokenInfo.getPayload();
        
        debugTrace('\nApplication received a token of grant type "' + decodedToken.grant_type + '".');

        token = encodedToken;
        scopes = decodedToken.scope || [];
        zid = decodedToken.zid;
        subaccountid = decodedToken["ext_attr"] ? decodedToken["ext_attr"].subaccountid : zid;
        if(!subaccountid) {
            subaccountid = zid;
        }

        clientId = decodedToken.cid;
        expirationDate = new Date(decodedToken.exp * 1000);
        grantType = decodedToken.grant_type;

        origin = decodedToken.origin || null;

        if (grantType !== constants.GRANTTYPE_CLIENTCREDENTIAL) {
            var givenName, familyName;
            if(decodedToken.ext_attr) {
                givenName = decodedToken.ext_attr.given_name || null;
                familyName = decodedToken.ext_attr.family_name || null;
            }

            userInfo.givenName = givenName || decodedToken.given_name || '';
            userInfo.familyName = familyName || decodedToken.family_name || '';
            userInfo.email = decodedToken.email || '';
            userInfo.logonName = decodedToken.user_name || '';

            debugTrace('\nObtained logon name: ' + this.getLogonName());
            debugTrace('Obtained given name: ' + this.getGivenName());
            debugTrace('Obtained family name: ' + this.getFamilyName());
            debugTrace('Obtained email: ' + this.getEmail());

            if (decodedToken.ext_cxt) {
                userAttributes = decodedToken.ext_cxt['xs.user.attributes'] || null;
                samlToken = decodedToken.ext_cxt['hdb.nameduser.saml'] || null;
            } else {
                userAttributes = decodedToken['xs.user.attributes'];
                samlToken = decodedToken['hdb.nameduser.saml'] || null;
            }

            userAttributes = cleanUpUserAttributes(userAttributes);

            if(userAttributes) {
                debugTrace('\nObtained attributes: ' + JSON.stringify(userAttributes, null, 4));
            } else {
                debugTrace('\nObtained attributes: no XS user attributes in JWT token available.');
            }
        }

        additionalAuthAttributes = decodedToken.az_attr || null;
        if(additionalAuthAttributes) {
            debugTrace('\nObtained additional authentication attributes: ' + JSON.stringify(additionalAuthAttributes, null, 4));
        } else {
            debugTrace('\nObtained attributes: no additional authentication attributes in JWT token available.');
        }

        if(decodedToken.ext_attr) {
            serviceinstanceid = decodedToken.ext_attr.serviceinstanceid || null;
            subdomain = decodedToken.ext_attr.zdn || null;
        }

        debugTrace('\nObtained subdomain: ' + this.getSubdomain());
        debugTrace('Obtained serviceinstanceid: ' + this.getCloneServiceInstanceId());
        debugTrace('Obtained origin: ' + this.getOrigin());
        debugTrace('Obtained scopes: ' + JSON.stringify(scopes, null, 4));
    }

    this.verifyToken = function (encodedToken, cb) {
        var verificationKey = new VerificationKey(config);
        var jwtValidator = new JwtTokenValidator(verificationKey, config);

        //Now validate the tokens
        jwtValidator.validateToken(encodedToken, function(err, tokenInfo) {
            if(err) {
                return cb(err, null, tokenInfo);
            }

            isForeignMode = jwtValidator.isForeignMode();

            //Token is now validated. So just fill local variables
            fillContext.call(this, encodedToken, tokenInfo);

            cb(null, this, tokenInfo);
        }.bind(this));
    };

    //call constructor
    ctor();
};